; classe che gestisce il caso in cui sia noto il contenuto di due caselle "k-cell"
(defmodule KNOWTWO (import MAIN ?ALL) (import ENV ?ALL) (import AGENT ?ALL)(export ?ALL))

; questa regola si attiva quando abbiamo top e bottom attaccati e 
; quindi troviamo una barca da due in verticale

(defrule top-front-bottom-two 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content top))
	(k-cell (x ?x1&:(eq (+ ?x 1) ?x1))(y ?y)(content bot))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x1)(y ?y))))
	?boats <- (closed-boats (two ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?row2 <- (k-per-row (row ?x1) (num ?val-row2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
	=>
	(modify ?boats(two (+ ?o 1)))
	(modify ?col1(num (- ?val-col1 2)))
	(modify ?row1(num (- ?val-row1 1)))
	(modify ?row2(num (- ?val-row2 1)))
	(assert(to-guess(x ?x) (y ?y)))
	(assert(to-guess(x ?x1) (y ?y)))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y ?y)))
	(assert(to-guess (x (+ ?x 2))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (- ?y 1))))
	(assert(exec (step ?s) (action guess) (x ?x1) (y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(printout t "(top-front-bottom-two) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma la barca e in orizzontale

(defrule left-front-right-two 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content left))
	(k-cell (x ?x)(y ?y1&:(eq (+ ?y 1) ?y1))(content right))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x)(y ?y1))))
	?boats <- (closed-boats (two ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?col2 <- (k-per-col (col ?y1&:(eq (+ ?y 1) ?y1)) (num ?val-col2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
    =>
    (modify ?boats(two (+ ?o 1)))
	(modify ?row1(num (- ?val-row1 2)))
	(modify ?col1(num (- ?val-col1 1)))
	(modify ?col2(num (- ?val-col2 1)))
	(assert(to-guess (x ?x)(y ?y)))
	(assert(to-guess	(x ?x)(y ?y1)))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x ?x)(y (+ ?y 2))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y ?y)))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 2))))
	(assert(exec (step ?s) (action guess) (x ?x)(y ?y1)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(printout t "(left-front-right-two)  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; si attiva nel momento in cui top e bottom di fronte ma con un 
; cubetto di distanza => barca da 3 in verticale

(defrule top-front-bottom-three 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content top))
	(k-cell (x ?x2&:(eq (+ ?x 2) ?x2))(y ?y)(content bot))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x2)(y ?y))))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?row2 <- (k-per-row (row ?x1&:(eq (+ ?x 1) ?x1)) (num ?val-row2))
	?row3 <- (k-per-row (row ?x2) (num ?val-row3))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
	=>
	(modify ?boats(three (+ ?o 1)))
	(modify ?col1(num (- ?val-col1 3)))
	(modify ?row1(num (- ?val-row1 1)))
	(modify ?row2(num (- ?val-row2 1)))
	(modify ?row3(num (- ?val-row3 1)))
	(assert(to-guess(x ?x) (y ?y)))
	(assert(to-guess(x ?x1) (y ?y)))
	(assert(to-guess(x ?x2) (y ?y)))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y ?y)))
	(assert(to-guess (x (+ ?x 3))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y (- ?y 1))))
	(assert(exec (step ?s) (action guess) (x ?x1) (y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x2)(y ?y)))
	(printout t "(top-front-bottom-three ) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)


;come sopra ma orizzontale

(defrule left-front-right-three  
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content left))
	(k-cell (x ?x)(y ?y2&:(eq (+ ?y 2) ?y2))(content right))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x)(y ?y2))))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?col3 <- (k-per-col (col ?y2) (num ?val-col3))
	?col2 <- (k-per-col (col ?y1&:(eq (+ ?y 1) ?y1)) (num ?val-col2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
    =>
    (modify ?boats(three (+ ?o 1)))
	(modify ?row1(num (- ?val-row1 3)))
	(modify ?col1(num (- ?val-col1 1)))
	(modify ?col2(num (- ?val-col2 1)))
	(modify ?col3(num (- ?val-col3 1)))
	(assert(to-guess (x ?x)(y ?y)))
	(assert(to-guess (x ?x)(y ?y1)))
	(assert(to-guess (x ?x)(y ?y2)))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 3))))
	(assert(to-guess (x ?x)(y (+ ?y 2))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y ?y)))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 3))))
	(assert(exec (step ?s) (action guess) (x ?x)(y ?y1)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y2)))
	(printout t "(left-front-right-three )  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; si attiva nel momento in cui top e bottom di fronte ma con  
; due cubetti di distanza => barca da 4 in verticale


(defrule top-front-bottom-four 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content top))
	(k-cell (x ?x3&:(eq (+ ?x 3) ?x3))(y ?y)(content bot))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x3)(y ?y))))
	?boats <- (closed-boats (four ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?row2 <- (k-per-row (row ?x1&:(eq (+ ?x 1) ?x1)) (num ?val-row2))
	?row3 <- (k-per-row (row ?x2&:(eq (+ ?x 2) ?x2)) (num ?val-row3))
	?row4 <- (k-per-row (row ?x3) (num ?val-row4))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
	=>
	(modify ?boats(four (+ ?o 1)))
	(modify ?col1(num (- ?val-col1 4)))
	(modify ?row1(num (- ?val-row1 1)))
	(modify ?row2(num (- ?val-row2 1)))
	(modify ?row3(num (- ?val-row3 1)))
	(modify ?row4(num (- ?val-row4 1)))
	(assert(to-guess(x ?x) (y ?y)))
	(assert(to-guess(x ?x1) (y ?y)))
	(assert(to-guess(x ?x2) (y ?y)))
	(assert(to-guess(x ?x3) (y ?y)))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 4))(y ?y)))
	(assert(to-guess (x (+ ?x 4))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 4))(y (- ?y 1))))
	(assert(exec (step ?s) (action guess) (x ?x1) (y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x2)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x3)(y ?y)))
	(printout t "(top-front-bottom-four ) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma orizzontale

(defrule left-front-right-four  
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content left))
	(k-cell (x ?x)(y ?y3&:(eq (+ ?y 3) ?y3))(content right))
	(or (not(guessed(x ?x)(y ?y)))
	(not(guessed(x ?x)(y ?y3))))
	?boats <- (closed-boats (four ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?col4 <- (k-per-col (col ?y3) (num ?val-col4))
	?col3 <- (k-per-col (col ?y2&:(eq (+ ?y 2) ?y2)) (num ?val-col3))
	?col2 <- (k-per-col (col ?y1&:(eq (+ ?y 1) ?y1)) (num ?val-col2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
    =>
    (modify ?boats(three (+ ?o 1)))
	(modify ?row1(num (- ?val-row1 4)))
	(modify ?col1(num (- ?val-col1 1)))
	(modify ?col2(num (- ?val-col2 1)))
	(modify ?col3(num (- ?val-col3 1)))
	(modify ?col4(num (- ?val-col4 1)))
	(assert(to-guess (x ?x)(y ?y)))
	(assert(to-guess (x ?x)(y ?y1)))
	(assert(to-guess (x ?x)(y ?y2)))
	(assert(to-guess (x ?x)(y ?y3)))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 3))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 4))))
	(assert(to-guess (x ?x)(y (+ ?y 2))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y ?y)))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 3))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 4))))
	(assert(exec (step ?s) (action guess) (x ?x)(y ?y1)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y2)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y3)))
	(printout t "(left-front-right-four )  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)


; questa regola si attiva quando abbiamo top e middle attaccati e 
; non si e potuta attivare la regola per la barca da 4 =>
; troviamo una barca da tre in verticale

(defrule top-front-middle-three 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content top))
	(k-cell (x ?x1&:(eq (+ ?x 1) ?x1))(y ?y)(content middle))
	(not (k-cell (x ?x2&:(eq (+ ?x 2) ?x2))(y ?y)))  ; non deve essere nota un'altra casella in quanto questa classe gestisce solo il caso in cui si conoscano 2 caselle
	(not(guessed(x ?x2&:(eq (+ ?x 2) ?x2))(y ?y)))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?row2 <- (k-per-row (row ?x1) (num ?val-row2))
	?row3 <- (k-per-row (row ?x2&:(eq (+ ?x 2) ?x2)) (num ?val-row3))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
	=>
	(modify ?boats(three (+ ?o 1)))
	(modify ?col1(num (- ?val-col1 3)))
	(modify ?row1(num (- ?val-row1 1)))
	(modify ?row2(num (- ?val-row2 1)))
	(modify ?row3(num (- ?val-row3 1)))
	(assert(to-guess(x ?x) (y ?y)))
	(assert(to-guess(x ?x1) (y ?y)))
	(assert(to-guess(x ?x2) (y ?y)))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 2))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y ?y)))
	(assert(to-guess (x (+ ?x 3))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 3))(y (- ?y 1))))
	(assert(exec (step ?s) (action guess) (x ?x1) (y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x2)(y ?y)))
	(printout t "(top-front-middle-three) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; questa regola si attiva quando abbiamo bottom e middle attaccati e 
; non si e potuta attivare la regola per la barca da 4 =>
; troviamo una barca da tre in verticale

(defrule bottom-front-middle-three 
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content bot))
	(k-cell (x ?x1&:(eq (- ?x 1) ?x1))(y ?y)(content middle))
	(not (k-cell (x ?x2&:(eq (- ?x 2) ?x2))(y ?y))) ; non deve essere nota un'altra casella in quanto questa classe gestisce solo il caso in cui si conoscano 2 caselle
	(not (guessed(x ?x2&:(eq (- ?x 2) ?x2))(y ?y)))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?row2 <- (k-per-row (row ?x1) (num ?val-row2))
	?row3 <- (k-per-row (row ?x2&:(eq (- ?x 2) ?x2)) (num ?val-row3))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
	=>
	(modify ?boats(three (+ ?o 1)))
	(modify ?col1(num (- ?val-col1 3)))
	(modify ?row1(num (- ?val-row1 1)))
	(modify ?row2(num (- ?val-row2 1)))
	(modify ?row3(num (- ?val-row3 1)))
	(assert(to-guess(x ?x) (y ?y)))
	(assert(to-guess(x ?x1) (y ?y)))
	(assert(to-guess(x ?x2) (y ?y)))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 2))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 2))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 3))(y ?y)))
	(assert(to-guess (x (- ?x 3))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 3))(y (- ?y 1))))
	(assert(exec (step ?s) (action guess) (x ?x1) (y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x2)(y ?y)))
	(printout t "(bottom-front-middle-three) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma la barca Ã¨ in orizzontale

(defrule left-front-middle-three  
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content left))
	(k-cell (x ?x)(y ?y1&:(eq (+ ?y 1) ?y1))(content middle))
	(not (k-cell (x ?x)(y ?y2&:(eq (+ ?y 2) ?y2)))) ; non deve essere nota un'altra casella in quanto questa classe gestisce solo il caso in cui si conoscano 2 caselle
	(not (guessed(x ?x)(y ?y2&:(eq (+ ?y 2) ?y2))))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?col3 <- (k-per-col (col ?y2&:(eq (+ ?y 2) ?y2)) (num ?val-col3))
	?col2 <- (k-per-col (col ?y1) (num ?val-col2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
    =>
    (modify ?boats(three (+ ?o 1)))
	(modify ?row1(num (- ?val-row1 3)))
	(modify ?col1(num (- ?val-col1 1)))
	(modify ?col2(num (- ?val-col2 1)))
	(modify ?col3(num (- ?val-col3 1)))
	(assert(to-guess (x ?x)(y ?y)))
	(assert(to-guess (x ?x)(y ?y1)))
	(assert(to-guess (x ?x)(y ?y2)))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 3))))
	(assert(to-guess (x ?x)(y (+ ?y 3))))
	(assert(to-guess (x ?x)(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y ?y)))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 2))))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 3))))
	(assert(exec (step ?s) (action guess) (x ?x)(y ?y1)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y2)))
	(printout t "(left-front-middle-three)  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma la barca e in orizzontale

(defrule right-front-middle-three  
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content right))
	(k-cell (x ?x)(y ?y1&:(eq (- ?y 1) ?y1))(content middle))
	(not (k-cell (x ?x)(y ?y2&:(eq (- ?y 2) ?y2)))) ; non deve essere nota un'altra casella in quanto questa classe gestisce solo il caso in cui si conoscano 2 caselle
	(not(guessed(x ?x)(y ?y2&:(eq (- ?y 2) ?y2))))
	?boats <- (closed-boats (three ?o))
	?row1 <- (k-per-row (row ?x) (num ?val-row1))
	?col3 <- (k-per-col (col ?y2&:(eq (- ?y 2) ?y2)) (num ?val-col3))
	?col2 <- (k-per-col (col ?y1) (num ?val-col2))
	?col1 <- (k-per-col (col ?y) (num ?val-col1))
    =>
    (modify ?boats(three (+ ?o 1)))
	(modify ?row1(num (- ?val-row1 3)))
	(modify ?col1(num (- ?val-col1 1)))
	(modify ?col2(num (- ?val-col2 1)))
	(modify ?col3(num (- ?val-col3 1)))
	(assert(to-guess (x ?x)(y ?y)))
	(assert(to-guess (x ?x)(y ?y1)))
	(assert(to-guess (x ?x)(y ?y2)))
	(assert(to-guess (x (- ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (- ?x 1))(y ?y)))
	(assert(to-guess (x (- ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 2))))
	(assert(to-guess (x (- ?x 1))(y (- ?y 3))))
	(assert(to-guess (x ?x)(y (- ?y 3))))
	(assert(to-guess (x ?x)(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y ?y)))
	(assert(to-guess (x (+ ?x 1))(y (+ ?y 1))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 2))))
	(assert(to-guess (x (+ ?x 1))(y (- ?y 3))))
	(assert(exec (step ?s) (action guess) (x ?x)(y ?y1)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y)))
	(assert (ausiliar-exec (action guess) (x ?x)(y ?y2)))
	(printout t "(right-front-middle-three)  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)


; questa regola si attiva quando abbiamo top e middle attaccati e 
; siamo in dubbio se la barca sia lunga 3 o sia lunga 4
; se dovesse andare a buon fine, la fire troverebbe un middle 
; e questo frebbe attivare la regola double middle, 
; se fallisce la fire trovera un bottom e si attivera la regola
; top-front-bottom-three che riconoscera una barca lunga 3


;da rivedere k-cell e guessed 

(defrule top-front-middle-four (declare (salience 1))
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content top))
	(moves (fires ?fires&:(> ?fires 0)))
	(k-cell (x ?x1&:(eq (+ ?x 1) ?x1))(y ?y)(content middle))
	(not (k-cell (x ?x2&:(eq (+ ?x 2) ?x2))(y ?y)))
	(or (not(guessed(x ?x2&:(eq (+ ?x 2) ?x2))(y ?y)))
	(not(guessed(x ?x3&:(eq (+ ?x 3) ?x3))(y ?y))))
	?boats <- (closed-boats (four ?o&:(< ?o 1)))
	?col1 <- (k-per-col (col ?y) (num ?val-col1&:(> ?val-col1 3 )))
	=>
	(assert(exec (step ?s) (action fire) (x (+ ?x 2)) (y ?y)))
	(printout t "(top-front-middle-four) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma avendo conoscendo bottom e middle 

(defrule bottom-front-middle-four (declare (salience 1))
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content bot))
	(moves (fires ?fires&:(> ?fires 0)))
	(k-cell (x ?x1&:(eq (- ?x 1) ?x1))(y ?y)(content middle))
	(not (k-cell (x ?x2&:(eq (- ?x 2) ?x2))(y ?y)))
	(or (not(guessed(x ?x2&:(eq (- ?x 2) ?x2))(y ?y)))
	(not(guessed(x ?x3&:(eq (- ?x 3) ?x3))(y ?y))))
	?boats <- (closed-boats (four ?o&:(< ?o 1)))
	?col1 <- (k-per-col (col ?y) (num ?val-col1&:(> ?val-col1 3 )))
	=>
	(assert(exec (step ?s) (action fire) (x (- ?x 2)) (y ?y)))
	(printout t "(bottom-front-middle-four) " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma la barca e in orizzontale

(defrule left-front-middle-four  (declare (salience 1))
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content left))
	(moves (fires ?fires&:(> ?fires 0)))
	(k-cell (x ?x)(y ?y1&:(eq (+ ?y 1) ?y1))(content middle))
	(not (k-cell (x ?x)(y ?y2&:(eq (+ ?y 2) ?y2))))
	(or (not(guessed(x ?x)(y ?y2&:(eq (+ ?y 2) ?y2))))
	(not(guessed(x ?x)(y ?y3&:(eq (+ ?y 3) ?y3)))))
	?boats <- (closed-boats (four ?o&:(< ?o 1)))
	?row1 <- (k-per-row (row ?x) (num ?val-row1&:(> ?val-row1 3)))
    =>
	(assert(exec (step ?s) (action fire) (x ?x)(y (+ ?y 2))))
	(printout t "(left-front-middle-four)  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)

; come sopra ma la barca e in orizzontale

(defrule right-front-middle-four  (declare (salience 1))
	(status (step ?s)(currently running))
	(k-cell (x ?x)(y ?y)(content right))
	(moves (fires ?fires&:(> ?fires 0)))
	(k-cell (x ?x)(y ?y1&:(eq (- ?y 1) ?y1))(content middle))
	(not (k-cell (x ?x)(y ?y2&:(eq (- ?y 2) ?y2))))
	(or (not(guessed(x ?x)(y ?y2&:(eq (- ?y 2) ?y2))))
	(not(guessed(x ?x)(y ?y3&:(eq (- ?y 3) ?y3)))))
	?boats <- (closed-boats (four ?o&:(< ?o 1)))
	?row1 <- (k-per-row (row ?x) (num ?val-row1&:(> ?val-row1 3)))
    =>
	(assert(exec (step ?s) (action fire) (x ?x)(y (- ?y 2))))
	(printout t "(left-front-middle-four)  x " ?x " y " ?y crlf)
	(assert(return))
    (pop-focus)
)